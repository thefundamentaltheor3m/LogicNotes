\section{Languages, Structures and Interpretations}

In this section, we discuss the notion of first-order languages and their interpretations in first-order structures. While this is primarily a study of semantics, the definition of languages is syntactic in nature. Yet, we consider this section to be a study of semantics because the purpose is to give some sort of meaning to the syntactic expressions we have in first-order languages.

We begin by studying first-order structures in an abstract sense. We then take a syntactic detour into the study of first-order languages, before examining what it means for structures to exist inside (and give interpretations for) first-order languages.

\subsection{First-Order Structures}

We begin by discussing relations and functions of a given arity.

\begin{boxdefinition}[$n$-ary Relation on a Set]
    Suppose $A$ is a set and $n \geq 1$ is a natural number. An \textbf{$n$-ary relation on $A$} is a subset
    \begin{align*}
        \Rb \subseteq \setst{\parenth{a_1, \ldots, a_n}}{a_1, \ldots, a_n \in A}
    \end{align*}
\end{boxdefinition}

We have a similar notion for functions, with the key fact being that $n$-ary functions take in $n$ inputs and return a single output, and all inputs and outputs must come from the set in question.

\begin{boxdefinition}[$n$-ary Function on a Set]
    Given a set $A$, an \textbf{$n$-ary function on $A$} is a function
    \begin{align*}
        \fb: A^n \to A
    \end{align*}
\end{boxdefinition}

We make a subtle distinction between functions and relations in formal and informal language. This is something that will get clearer as we progress.

\begin{boxconvention}
    The reason why we put bars on top of the symbols is to distinguish functions and relations as they appear in formulae from the way that discuss them.
\end{boxconvention}

We have special terms when $n = 1, 2, 3$.

\begin{boxconvention}
    \hfill
    \begin{enumerate}
        \item A $1$-ary relation is commonly called a \textbf{unary relation}.
        \item A $2$-ary relation is commonly called a \textbf{binary relation}.
        \item A $3$-ary relation is commonly called a \textbf{ternary relation}.
    \end{enumerate}
\end{boxconvention}

These notions are not new to us.

\begin{boxexample}[Some Familiar $n$-ary Relations]
    \hfill
    \begin{enumerate}
        \item Equality is a binary relation on any set.
        \item $\leq$ is a binary relation on $\R$.
        \item $\setst{x \in \Z}{x \text{ is even}}$ is a unary relation on $\Z$.
    \end{enumerate}
\end{boxexample}

Admittedly, the fact that the third example is precisely a set is a little unusual to see. This is because in practice, the following convention is used.

\begin{boxconvention}
    Let $\Rb \subseteq A^n$ be a relation on some set $A$. For all $\parenth{a_1, \ldots, a_n} \in A^n$, when we write
    \begin{align*}
        \Rbof{a_1, \ldots, a_n}
    \end{align*}
    or say that
    \begin{align*}
        \Rbof{a_1, \ldots, a_n} \text{ holds}
    \end{align*}
    we mean that $\parenth{a_1, \ldots, a_n} \in \Rb$.
\end{boxconvention}

We are now ready for the most important definition of this chapter.

\begin{boxdefinition}[First-Order Structure]\label{Ch2:Def:First-Order_Structure}
    A \textbf{first-order structure} is the following data:
    \begin{enumerate}
        \item a non-empty set $A$ called the \textbf{domain} of $\A$.
        
        \item a set of \textbf{relations} on $A$
        \begin{align*}
            \setst{\ol{R_i} \subseteq A^{n_i}}{i \in I}
        \end{align*}

        \item a set of \textbf{functions} on $A$
        \begin{align*}
            \setst{\ol{f_j} : A^{m_j} \to A}{j \in J}
        \end{align*}

        \item a set of \textbf{constants} that are elements of $A$
        \begin{align*}
            \setst{\ol{c_k} \in A}{k \in K}
        \end{align*}
    \end{enumerate}
    where $I, J, K$ are index sets that can be empty.
\end{boxdefinition}

Usually, the index sets of a first-order structure are subsets of $\N$, but in principle, they could be any set. We package the information about the constants and the arity of the functions and relations together in the following manner.

\begin{boxdefinition}[Signature]
    Let $\A$ be a first-order structure. The \textbf{signature} of $\A$ is the information
    \begin{align*}
        \setst{n_i}{i \in I}
        \qquad
        \setst{m_j}{j \in J}
        \qquad
        K
    \end{align*}
    with the respective sets describing the arity of the relations on $A$, the arity of the functions on $A$, and the index set of the constants in $A$.
\end{boxdefinition}

We use the following notation for first-order structures.

\begin{boxconvention}
    For a first-order structure $\A$ given as above, we wil deonte
    \begin{align*}
        \A = \cycl{A; \set{\ol{R_i}}_{i \in I}, \set{\ol{f_j}}_{j \in J}, \set{\ol{c_k}}_{k \in K}}
    \end{align*}
    More generally, we use the notation
    \begin{align*}
        \text{Structure} = \cycl{\text{Domain}; \text{Relations}, \text{Functions}, \text{Constants}}
    \end{align*}
\end{boxconvention}

We have encountered any number of first-order structures so far. Here are a few examples.

The first is a very basic example.
\begin{boxexample}[Orderings]
    We can take $A$ to be one of the sets $\N, \Z, \Q, \R$. We can define a first-order structure on $A$ with only one unary relation---that of ordering---and no functions or constants.
\end{boxexample}
It is important to note that while the sets $\N, \Z, \Q, \R$ all admit richer structures on them, they are not needed to define ordering. We don't even include equality in this description because a formula that contains an equality symbol is not about ordering.

In the next example, we look at an algebraic structure.
\begin{boxexample}[Groups]
    Every group is a first-order structure with the following data.
    \begin{enumerate}
        \item The domain is the set of elements of the group.
        \item The sole relation is the binary relation of equality.
        \item There is a binary function for the group operation and a unary function for inversion.
        \item There is a constant for the identity element.
    \end{enumerate}
\end{boxexample}
We can make a similar definition for rings.

We do not even need to talk about objects that we usually deal with as sets. We can also talk about graphs, which, while defined in terms of sets, are usually studied visually.
\begin{boxexample}[Graphs]
    Graphs (or, more precisely, their vertices), along with two binary relations---equality and adjacency---and no functions or constants, form a first-order structure.
\end{boxexample}

\subsection{First-Order Languages}

We are now ready to formally define the notion of first-order languages.

\begin{boxdefinition}[First-Order Language]\label{Ch2:Def:First-Order_Language}
    A \textbf{first-order language} $\L$ consists of the following data.
    \begin{enumerate}
        \item Index sets $I, J, K$ where $I$ is non-empty but $J$ and $K$ can be empty.
        \item An \textbf{alphabet} of symbols, consisting of
        \begin{enumerate}[noitemsep]
            \item \textbf{Variables} $x_0 \ x_1 \ x_2 \ \cdots$
            \item \textbf{Connectives} $\neg \ \to$
            \item \textbf{Punctuation} $( \ ) \ ,$
            \item The \textbf{Quantifier} $\forall$
            \item \textbf{Relation symbols} $R_i$ for $i \in I$
            \item \textbf{Function symbols} $f_j$ for $j \in J$
            \item \textbf{Constant symbols} $c_k$ for $k \in K$
        \end{enumerate}
        \item An \textbf{arity} for every relation and function symbol.
    \end{enumerate}
\end{boxdefinition}

The arity and cardinality information of a first-order language is encoded in the following manner.

\begin{boxdefinition}[Signature]
    Let $\L$ be a first-order language with index sets $I, J, K$ such that $I$ is non-empty and
    \begin{enumerate}
        \item The relations $\setst{R_i}{i \in I}$ have arities $\setst{n_i}{i \in I}$
        \item The functions $\setst{f_j}{j \in J}$ have arities $\setst{m_j}{j \in J}$
        \item The constants are given by $\setst{c_k}{k \in K}$
    \end{enumerate}
    The information
    \begin{align*}
        \setst{n_i}{i \in I}
        \qquad
        \setst{m_j}{j \in J}
        \qquad
        K
    \end{align*}
    is called the \textbf{signature} of $\L$.
\end{boxdefinition}

In principle, one should very precisely define punctuation rules and the general notation for expressing formulae in a first-order language. Indeed, what this means is that one should define what it means for a string of symbols to be `well-formed'. This is somewhat laborious, so we simply adopt the following convention.

\begin{boxconvention}
    We use the punctuation symbols
    \begin{align*}
        ( \quad ) \quad ,
    \end{align*}
    in the following manner.
    \begin{itemize}
        \item We enclose all expressions involving connectives in parentheses, barring those involving a single variable or a single constant.
        \item We enclose statements of the form ``$\forall x$'' in parentheses.
        \item We denote applications functions $f$ by $f(\cdots)$ and relations $R$ by $R(\cdots)$.
        \item We use commas to separate the arguments of functions and relations.
    \end{itemize}
\end{boxconvention}

There are numerous symbols in first-order languages. It makes sense to isolate the ones that form the `objects' with which we `reason' in this language.

\begin{boxdefinition}[Terms]
    Let $\L$ be a first-order language. The set of \textbf{terms} of $\L$ is the smallest set such that
    \begin{enumerate}
        \item Every variable is a term.
        \item Every constant is a term.
        \item If $t_1, \ldots, t_n$ are terms and $f$ is an $n$-ary function symbol, then $\fof{t_1, \ldots, t_n}$ is a term.
    \end{enumerate}
    Moreover, we shall stipulate that every term arises in this manner.
\end{boxdefinition}

We can define very basic first order languages.

\begin{boxexample}\label{Ch2:Eg:Terms_FO_Logic}
    Let $\L$ be a first-order language such that
    \begin{enumerate}
        \item There are no relations
        \item There is a binary function $f$
        \item There are two constants $c_1, c_2$
    \end{enumerate}
    Some terms of $\L$ are
    \begin{align*}
        c_1 \quad c_2 \quad x_1 \quad \fof{c_1, c_2} \quad \fof{x_1, c_1} \quad \fof{x_1, \fof{c_1, c_2}} \quad \fof{\fof{c_1, x_1}, c_2}
    \end{align*}
    There are many other terms. Note that we automatically assumed the existence of variables $x_1, x_2, \ldots$, which is consistent with \Cref{Ch2:Def:First-Order_Language}. 
\end{boxexample}
\begin{boxnexample}
    Let $\L$ be the \fola\ given in \Cref{Ch2:Eg:Terms_FO_Logic}. A string of symbols from the alphabet of $\L$ that is \textbf{not} a term is
    \begin{align*}
        f f x_1
    \end{align*}
    The reason for this is that $x_1$ is not applied to $f$, and even if we were to ignore the punctuation convention of writing function arguments inside parentheses, we would have that the arity of $f$ is violated, because a function of two variables is being applied (twice) to a single input (or the leftmost $f$ is being applied to both $f$ and $x_1$, which contradicts the fact that $f$ takes inputs that are both terms, and $f$ alone is not a term). It is precisely to avoid ambiguities of this sort that we have punctuation conventions; either way, in this case, there are too many errors for $f f x_1$ to be a term in $\L$.
\end{boxnexample}

We now define a way of using the quantifiers and connectives of \fola~s to build \textit{formulae}. The idea is to define a fundamental notion of formulae using purely the relations of the language and then define how more complex formulae can be built from them.

\begin{boxdefinition}[Atomic Formula]
    \Letla. An \textbf{atomic formula} of $\L$, or an \textbf{$\L$-atomic formula}, is an expression of the form
    \begin{align*}
        R\!\parenth{t_1, \ldots, t_n}
    \end{align*}
    where $R$ is an $n$-ary relation symbol in $\L$ and $t_1, \ldots, t_n$ are terms.
\end{boxdefinition}

Note that in the above definition, we do not require the inputs $t_1, \ldots, t_n$ to be variables or constants. We merely require them to be \textit{terms}. This means they could be variables, constants, or outputs of functions applied to other terms. Being `atomic' has only to do with being the output of a relation symbol. We can now define what a formula is in a broader sense.

\begin{boxdefinition}[Formula]
    \Letla. The \textbf{formulae} of $\L$, or the \textbf{$\L$-formulae}, are defined as follows.
    \begin{enumerate}
        \item Every atomic formula is a formula.
        \item If $\phi$ is a formula, then so is $\parenth{\neg \phi}$.
        \item If $\phi$ and $\psi$ are formulae, then so is $\parenth{\phi \to \psi}$.
        \item If $\phi$ is a formula, then so is $\parenth{\forall x} \phi$.
    \end{enumerate}
    Moreover, we stipulate that every formula arises in this manner.
\end{boxdefinition}

We can define very simple formulae in very simple \fola~s.

\begin{boxexample}
    \Letla\ with
    \begin{enumerate}
        \item One unary relation symbol $P$ and one binary relation symbol $R$
        \item One binary function symbol $f$
        \item Two constants $c_1$ and $c_2$
    \end{enumerate}
    Then, the following are all atomic formulae:
    \begin{align*}
        P\!\parenth{x_1} \quad R\!\parenth{c_1, x_1} \quad R\!\parenth{\fof{x_1, c_1}, c_2}
    \end{align*}
    Similarly, the following are all formulae:
    \begin{align*}
        \neg P\!\parenth{x_1} \quad \parenth{P\!\parenth{x_1} \to R\!\parenth{c_1, x_1}} \quad \parenth{\forall x} R\!\parenth{x, c_1}
    \end{align*}
\end{boxexample}

There is a reason why we only allowed \fola~s to have connectives $\to$ and $\neg$ and quantifier $\forall$: we can build the other connectives ($\land, \lor, \lr, \ldots$) and the other quantifier ($\exists$) from these.

\begin{boxdefinition}[The Existential Quantifier]
    \Letla\ and let $\phi$ be an $\L$-formula. Then, we define
    \begin{align*}
        \parenth{\exists x} \phi
    \end{align*}
    to be shorthand for the formula
    \begin{align*}
        \parenth{\neg\parenth{\forall x}\parenth{\neg \phi}}
    \end{align*}
\end{boxdefinition}

We also define the other connectives as in propositional logic.

\begin{boxdefinition}[Connectives]
    \Letla. Let $\phi$ and $\psi$ be $\L$-formulae. We define the connectives $\land, \lor, \lr, \uparrow, \downarrow$ as follows:
    \begin{align*}
        \parenth{\phi \land \psi} &\text{ is shorthand for } \parenth{\neg (\phi \to \neg \psi)} \\
        \parenth{\phi \lor \psi} &\text{ is shorthand for } \parenth{\parenth{\neg \phi} \to \psi} \\
        \parenth{\phi \lr \psi} &\text{ is shorthand for } \parenth{(\phi \to \psi) \land (\psi \to \phi)} \\
        \parenth{\phi \uparrow \psi} &\text{ is shorthand for } \parenth{\neg (\phi \land \psi)} \\
        \parenth{\phi \downarrow \psi} &\text{ is shorthand for } \parenth{\neg (\phi \lor \psi)}
    \end{align*}
\end{boxdefinition}

We are now ready to explore the utility of first-order logic in the study of mathematics, where we relate the study of first-order structures to first-order languages.

\subsection{First-Order Structures Revisited}

Throughout this subsection, we will fix a first-order language $\L$ with signature
\begin{align*}
    \setst{n_i}{i \in I}
    \qquad
    \setst{m_j}{j \in J}
    \qquad
    K
\end{align*}
where the $n_i$s are the arities of the relation symbols $R_i$, the $m_j$ are the arities of the function symbols $f_j$, and $K$ is the index set of the constants $c_k$.

\begin{boxdefinition}[First-Order Structures in First-Order Languages]\label{Ch2:Def:First-Order_Structure_in_First-Order_Language}
    A \textbf{structure} in $\L$, or an \textbf{$\L$-structure}, is a first-order structure
    \begin{align}
        \A = \cycl{A; \set{\ol{R_i}}_{i \in I}, \set{\ol{f_j}}_{j \in J}, \set{\ol{c_k}}_{k \in K}}
        \label{Ch2:Eq:FOS_Generic}
    \end{align}
    such that the signature of $\A$ is the same as that of $\L$, ie, the arities of the relations and functions in $\A$ are the same as those in $\L$.
\end{boxdefinition}

If one takes a closer look at the definitions of first-order structures and first-order languages (resp. \Cref{Ch2:Def:First-Order_Structure} and \Cref{Ch2:Def:First-Order_Language}), one notices that the former involves \textbf{actual} relations and functions, which are defined as subsets of certain sets, whereas the latter merely involves function and relation \textbf{symbols}. This is a crucial distinction.

\begin{boxconvention}
    The reason why we put bars on top of the symbols is to distinguish functions and relations as they appear in first-order structures---\textit{with} bars on top---from the way we express them in the ambient first-order language.
\end{boxconvention}

For the remainder of this subsection, fix a \fos\ $\A$. Denote its domain, relations, functions and constants as in~\eqref{Ch2:Eq:FOS_Generic}, with bars above as per our convention for this module. We now discuss the significance of first-order structures and underscore the power and versatility of first-order languages.

When we say, in \Cref{Ch2:Def:First-Order_Structure_in_First-Order_Language}, that the signature of an $\L$-structure is the same as that of the first-order language $\L$, we mean that the arities of the relations in the structure must match up with the arities of the relation symbols in the language, and similarly for functions and constants. More precisely, we have the following.

\begin{boxdefinition}[Interpretation]
    \Letal. The correspondence
    \begin{align*}
        \ol{R_i} \lrsquig R_i
        \qquad
        \ol{f_j} \lrsquig f_j
        \qquad
        \ol{c_k} \lrsquig c_k
    \end{align*}
    between relations, functions and constants in $\A$ and relation symbols, function symbols and constant symbols in $\L$ is called an \textbf{interpretation of $\L$}.
\end{boxdefinition}

We have a special term for the ``$\L$ to $\A$'' direction of this correspondence.

\begin{boxdefinition}[Valuation]\label{Ch2:Def:Valuation}
    Let $\A$ be an $\L$-structure. A \textbf{valuation} in $\A$ is a function
    \begin{align*}
        \v : \set{\text{Terms of } \L} \to A
    \end{align*}
    that assigns terms of $\L$ to their interpretations in $\A$ in the following manner.
    \begin{enumerate}
        \item For all constant symbols $c_k$ in $\L$, we have
        \begin{align*}
            \vof{c_k} = \ol{c_k}
        \end{align*}
        
        \item For all terms $t_1, \ldots, t_m$ and $m$-ary function symbols $f$ in $\L$, we have
        \begin{align*}
            \vof{\fof{t_1, \ldots, t_m}} = \ol{f}\!\parenth{\vof{t_1}, \ldots, \vof{t_m}}
        \end{align*}
        where $\ol{f}$ is the interpretation of $f$ in $\A$.
    \end{enumerate}
\end{boxdefinition}

The idea is that a first-order language gives a purely symbolic way of expressing relationships between objects and their properties. When studying statements expressed in first-order languages, one must purely view them symbolically, as formal expressions that do not carry any \textit{meaning} per se. The `meaning' comes from valuations that allow us to interpret symbols in first-order languages as ideas in first-order structures.

We have an existence and uniqueness result.
\begin{boxlemma}\label{Ch2:Lemma:Valuation_Existence_Uniqueness}
    \Letal\ with domain $A$. Fix elements $a_0, a_1, a_2, \ldots \in A$. There exists a unique valuation $\v$ of $\L$ in $\A$ such that $\vof{x_i} = a_i$ for all $i \in \N$.
\end{boxlemma}
\begin{proof}
    We begin by showing existence. We can define $\v$ explicitly for all terms of $\L$ by performing recursion on their length. For terms of length $1$, we deal with the variables and the distinguished constants separately.
    \begin{enumerate}
        \item $\vof{x_i} := a_i$ for all $i \in \N$
        \item $\vof{c_k} := \ol{c_k}$ for all $k \in K$
    \end{enumerate}
    We can then define $\v$ for terms arising from functions and relations of arity $\geq 2$ by setting
    \begin{align*}
        \vof{\fof{t_1, \ldots, t_m}} &:= \fbof{\vof{t_1}, \ldots, \vof{t_m}}
    \end{align*}
    for all terms $t_1, \ldots, t_m$ and $m$-ary function symbols $f$ in $\L$ with interpretation $\ol{f}$ in $\A$. Such a valuation is unique because if there are two valuations satisfying the condition on the variables, then they agree on \underline{all} terms of length $1$ (because they must agree on all constants---see \Cref{Ch2:Def:Valuation}). The fact that they obey the recursion relation by definition then gives us the result.
\end{proof}

\begin{boxexample}[A Formula in Groups]
    Let $\L$ have the following data.
    \begin{enumerate}
        \item Function symbols: a binary symbol $m$ and a unary symbol $i$.
        \item Relation symbols: a binary symbol $R$.
        \item Constant symbols: a constant symbol $e$.
    \end{enumerate}
    The following is an $\L$-formula:
    \begin{align*}
        m\of{m\of{x_0, x_1}, i\of{x_0}}
    \end{align*}
    Consider the first-order structure $\A$, meant to represent a group, with the underlying data.
    \begin{enumerate}
        \item Domain: $G$, a set.
        \item Functions: the binary function $\ol{m}$ of multplication (the group operation) and the unary function $\ol{i}$ of inversion.
        \item Relations: the binary relation $\Rb$ of equality.
        \item Constants: the identity element $\ol{e}$.
    \end{enumerate}
    Fix arbitrary group elements $g, h \in G$. We know, from \Cref{Ch2:Lemma:Valuation_Existence_Uniqueness}, that there exists a unique valuation $\v$ of $\L$ in $\A$ such that $\vof{x_0} = g$ and $\vof{x_1} = h$. This valuation will allow us to interpret the formula above as a statement about the group elements $g$ and $h$:
    \begin{align*}
        \vof{m\of{m\of{x_0, x_1}, i\of{x_0}}}
        &= \ol{m}\of{\vof{m\of{x_0, x_1}}, \vof{i\of{x_0}}} \\
        &= \ol{m}\of{\ol{m}\of{\vof{x_0}, \vof{x_1}}, \ol{i}\of{\vof{x_0}}} \\
        &= \ol{m}\of{\ol{m}\of{g, h}, \ol{i}\of{g}} \\
        &= \ol{m}\of{g \cdot h, g\inv} \\
        &= ghg\inv
    \end{align*}
    If we had defined the structure $\A$ a little differently---for example, if we had defined $\ol{m}\of{g, h} := hg$ instead---then the interpretation of the formula in $\A$ would have been different, despite the formula itself being exactly the same in $\L$. This illustrates the role of valuations and interpretations in moving between purely formal, syntactic expressions in first-order languages to meaningful expressions or statements in first-order structures.
\end{boxexample}

\begin{remark}
    It is worth remarking that in the above example, we use the $=$ symbol somewhat frivolously. On the one hand, left- and right-hand sides of each equation lie in $G$, and $=$ can be understood as equality in $\A$. However, one can also view these as being a \textit{syntactic} equalities in $\A$, since the properties we use to manipulate the above expressions are independent of the group structure of $\A$. The only simplifications we make come from the \textit{definitions} of  $\v$, $\ol{m}$, and $\ol{i}$ (for that matter, we can even view $\cdot$ and $\inv$ as notation for $\ol{m}$ and $\ol{i}$ instead of viewing $\ol{m}$ and $\ol{i}$ as notation for $\cdot$ and $\inv$). We sidestep these syntactic nuances in this module, but we do mention that a more syntax-heavy treatment is necessary for a computer-scientific study of first-order logic.
\end{remark}

With this, we have studied first-order languages and structures in sufficient detail to be able to talk about how we can express and implement ideas from propositional logic in first-order logic.
